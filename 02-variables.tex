% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{변수, 표현식, 스테이트먼트(Statement)}

\section{값(Value)과 형식(Type)}
\index{value}
\index{type}
\index{string}

{\bf 값(Value)}는 문자와 숫자처럼 프로그램이 다루는 가장 기본이되는 단위이다. 우리가 지금까지 살펴본 값은 {\tt 1},{\tt 2} 그리고 \verb"'Hello,World!' ('안녕 세상!')" 이다.

이들 값들은 다른 형식에 속해있는데, {\tt 2}는 정수, \verb" 'Hello,World!' ('안녕 세상!')" 는 {\bf 문자열(String)}에 속해있다. 문자(Letter)의 열에 있어서 문자열이라고 부른다. 여러분과 인터프리터는 문자열을 확인할 수 있는데 이유는 인용부호 따옴표에 쌓여있기 때문이다.

{\tt print } 문은 정수에도 사용할 수 있다. {\tt python} 명령어를 실행하여 인터프리터를 구동시키자.

\index{quotation mark}

\beforeverb
\begin{verbatim}
python
>>> print 4
4
\end{verbatim}
\afterverb
%
값의 형식을 확신을 못한다면, 인터프리터가 알려준다.

\beforeverb
\begin{verbatim}
>>> type('Hello, World!')
<type 'str'>
>>> type(17)
<type 'int'>
\end{verbatim}
\afterverb
%

놀랍지도 않게, strings은 {\tt str} 형식이고, 정수는 {\tt int} 형식이다. 소숫점을 가진 숫자는 {\tt float} 형식이다. 왜냐하면 이들 숫자가 {\bf 부동소수점} 형식으로 표현되기 때문이다.

\index{type}
\index{string type}
\index{type!str}
\index{int type}
\index{type!int}
\index{float type}
\index{type!float}

\beforeverb
\begin{verbatim}
>>> type(3.2)
<type 'float'>
\end{verbatim}
\afterverb
%
\verb"'17'", \verb"'3.2'" 같은 값은 어떨가? 문자처럼 보이지만 문자처럼 따옴표안에 쌓여있다.

\index{quotation mark}

\beforeverb
\begin{verbatim}
>>> type('17')
<type 'str'>
>>> type('3.2')
<type 'str'>
\end{verbatim}
\afterverb
%
\verb"'17'", \verb"'3.2'" 은 문자열이다.

아주 큰 정수를 입력할, {\tt 1,000,000} 처럼 세자리 숫자마다 콤마(,)를 입력한다. 하지만, 파이썬에서 적법한 정수는 아니지만 적법하다.

\beforeverb
\begin{verbatim}
>>> print 1,000,000
1 0 0
\end{verbatim}
\afterverb
%
하지만, 파이썬이 뱉은 값은 우리가 기대했던 것이 아니다. 파이썬은 {\tt 1,000,000} 을 콤마로 구분된 정수로 인식한다. 따라서 사이 사이 공백을 넣어 출력했다.

\index{semantic error}
\index{error!semantic}
\index{error message}

이 사례가 여러분이 처음 경험하게 되는 시맨틱 오류이다. 코드가 에러 메세지 없이 실행이되지만, ''올바르게(right)'' 작동을 하는 것은 아니다.


\section{변수(Variable)}
\index{variable}
\index{assignment statement}
\index{statement!assignment}

프로그래밍 언어의 가장 강력한 기능중의 하나는 변수를 다룰 수 있는 능력이다. {\bf 변수(Variable)}는 값을 참조할 수 있는 이름이다.

{\bf 할당 스테이스먼트(Assignment statement)}는 새로운 변수를 생성하고 값을 준다.

\beforeverb
\begin{verbatim}
>>> message = 'And now for something completely different'
>>> n = 17
>>> pi = 3.1415926535897931
\end{verbatim}
\afterverb
%
위의 예제는 세개의 할당을 보여준다. 첫번째 할당의 예제는 {\tt message} 변수에 문자열을 할당한다. 두번째 예제는 변수 {\tt n}에 정수 {\tt 17}을 할당한다. 세번째 예제는 {\tt pi}변수에 $\pi$ 근사값을 할당하는 경우이다.

변수의 값을 출력하기 위해서 {\tt print} 스테이트먼트를 사용한다.

\beforeverb
\begin{verbatim}
>>> print n
17
>>> print pi
3.14159265359
\end{verbatim}
\afterverb
%

변수의 형식은 변수가 참조하는 값의 형식이다.

\beforeverb
\begin{verbatim}
>>> type(message)
<type 'str'>
>>> type(n)
<type 'int'>
>>> type(pi)
<type 'float'>
\end{verbatim}
\afterverb
%

\section{변수명(Variable name)과 예약어(keywords)}
\index{keyword}
대체로 프로그래머는 의미있는 변수명을 고른다. 프로그래머는 변수가 어디에 사용되는지를 문서화도 한다.

변수명은 임의로 길 수 있다. 변수명은 문자와 숫자를 포함할 수 있지만, 통상 문자로 시작한다. 대문자를 사용하는 것도 적합하지만 소문자로 시작하는 변수명으로 시작하는 것도 좋은 생각이다. (후에 왜 그런지 보게될 것이다.)

변수명에 밑줄(underscore character, \verb"_")이 들어갈 수 있다. 밑줄은 \verb"my_name" 혹은 \verb"airspeed_of_unladen_swallow" 처럼 여러 단어와 함께 사용된다.

\index{underscore character}

적합하지 못한 변수명을 사용하면, 구문 오류를 보게된다.

\beforeverb
\begin{verbatim}
>>> 76trombones = 'big parade'
SyntaxError: invalid syntax
>>> more@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%

{\tt 76trombones} 변수명은 문자로 시작하지 않아서 적합하지 않다. {\tt more@}는 특수 문자 ({\tt @})를 변수명에 포함해서 적합하지 않다. {\tt class} 변수명은 뭐가 잘못된 것일까?

{\tt class}는 파이썬의 예약어 중의 하나이다. 인터프리터는 예약어를 프로그램 구조를 파악하기 위해서 사용하고 변수명으로는 사용할 수 없다.

\index{keyword}

파이썬의 31개의 키워드\footnote{In Python 3.0, {\tt exec} is no
longer a keyword, but {\tt nonlocal} is.}를 예약어로 이미 가지고 있다.

\beforeverb
\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}
\afterverb
%
여러분은 예약어 목록을 잘 가지고 다니고 싶을 것입니다. 인터프리터가 변수명 중에서 불평하고 이유를 모를 경우 예약어 목록에 있는지 확인해 보세요.

\section{스테이트먼트(Statement)}

{\bf 스테이트먼트(statement)}는 파이썬 인터프리터가 실행하는 코드의 단위입니다. print, assignment 두 종류의 스테이트먼트를 봤습니다.

\index{statement}
\index{interactive mode}
\index{script mode}

인터랙트브 모드에서 스테이트먼트를 입력할 때, 만약 한줄이면 인터프리터는 스테이트먼트를 실행하고 결과를 출력합니다.

스크립트는 보통 여러줄의 스테이트먼트로 구성됩니다. 하나 이상의 스테이트먼트가 있다면, 스트테이트먼트가 실행되며 결과가 한번에 나타납니다.

예를 들어, 다음의 스크립트를 생각해 봅시다.

\beforeverb
\begin{verbatim}
print 1
x = 2
print x
\end{verbatim}
\afterverb
%

위 스크립트는 다음의 결과를 출력합니다.

\beforeverb
\begin{verbatim}
1
2
\end{verbatim}
\afterverb
%
할당 스테이트먼트{\tt (x=2)}는 결과를 출력하지 않습니다.

\section{연산자(Operator)와 피연산자(Operands)}
\index{operator, arithmetic}
\index{arithmetic operator}
\index{operand}
\index{expression}

{\bf 연산자(Operators)}는 덧셈과 곱셈 같은 연산(Computation)을 표현하는 특별한 기호입니다. 연산가자 적용되는 값을 {\bf 피연산자(operands)}라고 합니다.

다음의 예제에서 보듯이, {\tt +}, {\tt -}, {\tt *}, {\tt /}, {\tt **} 연산자는 덧셈, 뺄셈, 곱셈, 나눗셈, 누승을 수행합니다.

\beforeverb
\begin{verbatim}
20+32   hour-1   hour*60+minute   minute/60   5**2   (5+9)*(15-7)
\end{verbatim}
\afterverb
%
나눗셈 연산자는 여러분이 기대하는 행동을 하지 않을 수도 있습니다.

\beforeverb
\begin{verbatim}
>>> minute = 59
>>> minute/60
0
\end{verbatim}
\afterverb
%
{\tt minute} 값은 59, 보통 59를 60으로 나누면 0 대신에 0.98333 입니다. 이런 차이가 발생하는 이유는 파이썬이 부동 소숫점 나눗셈을 하기 때문입니다.

\index{Python 3.0}
\index{floor division}
\index{floating-point division}
\index{division!floor}
\index{division!floating-point}


두 개의 피연산자가 정수이면, 결과도 정수입니다. {\bf 부동 소수점 나눗셈}\footnote{파이썬 3.0 에서
이 나눗셈의 값은 {\tt 소수점}입니다. 파이썬 3.0 에서  새로운 연산자{\tt //}는 정수 나눗셈을 수행합니다.}
은 소수점 이하를 절사해서 이 예제에서는 소수점이하 잘라버려 0 이 됩니다.

\beforeverb
\begin{verbatim}
>>> minute/60.0
0.98333333333333328
\end{verbatim}
\afterverb

\section{(표현)식(Expression)}
{\bf (표현)식 (expression)}은 값, 변수, 연산자의 조합니다. 값은 자체로 표현식이고, 변수도 동일합니다. 따라서 다음의 표현식은 모두 적합합니다. (변수 {\tt x}에 사전에 어떤 값이 할당되었다고 가정하고)

\index{expression}
\index{evaluate}

\beforeverb
\begin{verbatim}
17
x
x + 17
\end{verbatim}
\afterverb
%
인터랙티브 모드에서 표현식을 입력하면, 인터프리터는 표현식을 {\bf 평가(evaluate)}하고 값을 표시합니다.

\beforeverb
\begin{verbatim}
>>> 1 + 1
2
\end{verbatim}
\afterverb
%

하지만, 스크립트에서는 표현식 자체로 어떠한 것도 수행하지는 않습니다. 초심자에게 혼란스러운점입니다.


\begin{ex}

파이썬 인터프리터에 다음의 스테이트먼트를 입력하고 결과를 보세요.

\beforeverb
\begin{verbatim}
5
x = 5
x + 1
\end{verbatim}
\afterverb
%
\end{ex}


\section{연산자 적용 우선순위 (Order of Operations)}
\index{order of operations}
\index{rules of precedence}
\index{PEMDAS}

1개 이상의 연산자가 표현식에 등장할때 연산자 실행의 순서는 {\bf  순위 규칙(rules of precedence)}에 따른다. 수학 연산자에 대해서 파이썬은 수학의 관례를 동일하게 따른다. 영어 두문어 {\bf PEMDAS}는 기억하기 좋은 방식이다.

\index{parentheses!overriding precedence}

\begin{itemize}

\item {\bf 괄호(Parentheses)}는 가장 높은 순위를 가지고 여러분이 원하는 순위에 맞춰 실행할 때 사용한다. 괄호안에 있는 식이 먼저 실행되기 때문에 {\tt 2 * (3-1)} 은 4가 정답이고, {\tt (1+1)**(5-2)}는 8이다. 괄호를 표현식을 읽기 쉽게하려고 사용하기도 한다. {\tt (minute * 100) / 60} 는 실행순서가 결과값에 영향을 주지 않지만 가독성이 상대적으로 좋다.

\item {\bf 멱승(Exponentiation)}이 다음으로 높은 우선순위를 가진다. 그래서 {\tt 2**1+1}는 4가 아니라 3이고, {\tt 3*1**3}는 27이 아니고 3이다. 

\item {\bf 곱셈(Multiplication)과 나눗셈(Division)}은 덧셈(Addition), 뺄셈(Substraction)보다 높은 우선 순위를 가지고 같은 실행의 순위를 갖는다. {\tt 2*3-1}는 4가 아니고 5이고, {\tt 6+4/2}는 5가 아니라 8이다.

\item 같은 실행의 순위를 갖는 연산자는 왼쪽에서 오른쪽으로 실행된다. {\tt 5-3-1} 표현식은 3이 아니고 1이다. 왜냐하면 {\tt 5-3}이 먼저 실행되고 나서 {\tt 2}에서 {\tt 1}을 빼기 때문이다.

\end{itemize}

여러분이 의도한 순서대로 연산이 일어날수 있도록 좀 의심스러운 경우는 괄호를 사용하세요.

\section{나머지 연산자 (Modulus Operator)}

\index{modulus operator}
\index{operator!modulus}

{\bf 나머지 연산자(modulus operator)}는 정수에 사용하며, 첫번째 피연산자가 두번째 피연산자로 나눌 때 나머지 값을 만들어 냅니다. 파이썬에서 나머지 연산자는 퍼센트 기호(\verb"%")입니다. 구문은 다른 연산자와 동일합니다.

\beforeverb
\begin{verbatim}
>>> quotient = 7 / 3
>>> print quotient
2
>>> remainder = 7 % 3
>>> print remainder
1
\end{verbatim}
\afterverb
%
7을 3으로 나누면 2가 되고 1을 나머지로 갖게됩니다.

나머지 연산자가 놀랍도록 유용합니다. 예를 들어 한 숫자가 다른 숫자로 나눌 수 있는지 없는지를 확인할 수도 있습니다. {\tt x \% y}가 0이라면 {\tt x}는 {\tt y}로 나눌 수 있습니다.

\index{divisibility}

또한, 숫자로부터 가장 오른쪽의 숫자를 분리하는데 사용할 수도 있습니다. 예를 들어 {\tt x \% 10} 은 {\tt x}의 10진수인 경우 가장 오른쪽 숫자를 뽑아낼 수 있고, 동일하게 {\tt x \% 100}은 가장 오른쪽 2개 숫자를 뽑아낼 수도 있습니다.

\section{문자열 연산자 (String Operator)}
\index{string!operation}
\index{operator!string}

{\tt +} 연산자는 문자열에도 사용할 수 있지만, 수학에서의 덧셈의 의미는 아닙니다. 대신에 문자열의 끝과 끝을 연결하여 {\bf 접합(concatenation)}을 수행합니다. 예를 들어

\index{concatenation}

\beforeverb
\begin{verbatim}
>>> first = 10
>>> second = 15
>>> print first+second
25
>>> first = '100'
>>> second = '150'
>>> print first + second
100150
\end{verbatim}
\afterverb
%
이 프로그램의 출력은 {\tt 100150} 입니다.

\section{사용자에게서 입력값 받기}
\index{keyboard input}

때때로 키보드를 통해서 사용자에게서 변수에 대한 값을 받고 싶을 때가 있습니다. 키보드\footnote{파이썬 3.0에서 이 함수는 {\tt input}으로 명명되었습니다.}로부터 입력값을 받을 수 있는 \verb"raw_input" 이라는 빌트인(built-in) 함수를 파이썬은 제공합니다. 이 함수가 실행될 때 파이썬은 실행을 멈추고 사용자로부터 입력 받기를 기다립니다. 사용자가 {\sf Return} 혹은 {\sf 엔터}를 누르게되면 프로그램은 다시 실행되고 \verb"raw_input"은 사용자가 입력한 값을 문자열로 반환합니다.

\index{Python 3.0}
\index{raw\_input function}
\index{function!raw\_input}

\beforeverb
\begin{verbatim}
>>> input = raw_input()
Some silly stuff
>>> print input
Some silly stuff
\end{verbatim}
\afterverb
%
사용자로부터 입력을 받기 전에 프롬프트에서 사용자에게 어떤 값을 입력해야하는지 출력하는 것도 좋은 생각이다. 입력값을 위해 잠시 멈춰있기 전에 \verb"raw_input" 함수에 출력될 문자열에 대한 정보를 사용자에게 전달하는 것이다.

\index{prompt}

\beforeverb
\begin{verbatim}
>>> name = raw_input('What is your name?\n')
What is your name?
Chuck
>>> print name
Chuck
\end{verbatim}
\afterverb
%

프롬프트의 끝에 \verb"\n" 은 {\bf 새줄(newline)}을 의미합니다. 새줄은 줄을 바꾸게 하는 특수 문자입니다. 이런 이유 때문에 사용자의 입력이 프롬프트 밑에 출력이 됩니다.

\index{newline}

만약 사용자가 정수를 입력하기를 바란다면, {\tt int()}함수를 사용하여 반환되는 값을 {\tt 정수(int)}로 형변환할 수 있습니다.

\beforeverb
\begin{verbatim}
>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
17
>>> int(speed)
17
>>> int(speed) + 5
22
\end{verbatim}
\afterverb
%
하지만, 사용자가 숫자 문자열이 아닌 다른 것을 입력하게 되면 오류가 발생합니다.

\beforeverb
\begin{verbatim}
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int()
\end{verbatim}
\afterverb
%

이런 종류의 오류를 나중에 더 만나게 될 것입니다.

\index{ValueError}
\index{exception!ValueError}


\section{주석(Comment)}
\index{comment}

프로그램이 커지고 복잡해짐에 따라 읽기는 점점 어려워집니다. 형식언어로 촘촘하고 코드의 일부분을 읽기 어렵고 무슨 역할을 왜 수행하는지 이해하기 어렵습니다.

이런 이유로 프로그램이 무엇을 하는지를 일반적인 언어로 프로그램에 노트를 달아놓는게 좋은 습관입니다. 이러한 노트를 {\bf 주석(Comments)}라고 하고 \verb"#" 기호로 시작합니다.


\beforeverb
\begin{verbatim}
# 경과한 시간의 퍼센트를 계산
percentage = (minute * 100) / 60
\end{verbatim}
\afterverb
%
이 경우, 주석 자체가 한줄이다. 주석을 프로그램의 뒤에 놓을 수도 있다.

\beforeverb
\begin{verbatim}
percentage = (minute * 100) / 60     # 경과한 시간의 퍼센트를 계산
\end{verbatim}
\afterverb
%

{\tt \#} 뒤의 모든 것은 무시되기 때문에 프로그램에는 아무런 영향이 없습니다.
주석은 코드의 명확하지 않은 점을 문서화할 때 가장 유용합니다. 프로그램을 읽는 사람이 코드가 \emph{무엇}을 하는지 이해할 수 있다고 가정하는 것은 그럴 듯합니다. \emph{왜} 그런지를 설명하는 것은 더더욱 유용합니다.

다음의 주석은 코드와 중복으로 쓸모가 없습니다.

\beforeverb
\begin{verbatim}
v = 5     # assign 5 to v
\end{verbatim}
\afterverb
%

다음의 주석은 코드에 없는 유용한 정보가 있습니다.

\beforeverb
\begin{verbatim}
v = 5     # velocity in meters/second. 
\end{verbatim}
\afterverb
%
좋은 변수명은 주석을 할 필요를 없게 만들지만, 지나치게 긴 변수명은 읽기 어려운 복잡한 표현식이 될 수도 있기 때문에 상충관계(trade-off)가 존재합니다.

\section{기억하기 쉬운 변수명 만들기}

\index{mnemonic}

변수를 이름 짓는 간단한 규칙을 따르고, 예약어를 피하기만 하면 변수를 이름지을 수 있는 무척이나 많은 경우의 수가 존재합니다. 처음에 이러한 선택의 폭이 프로그램을 읽는 사람이나 프로그램을 작성하는 사람 모두에게 혼란스러울 수 있습니다. 예를 들어, 다음의 3개 프로그램은 수행하는 것이 동일하다는 점에서 동일하지만 여러분이 읽고 이해하는데는 많은 차이점이 있습니다.

\beforeverb
\begin{verbatim}
a = 35.0
b = 12.50
c = a * b
print c

hours = 35.0
rate = 12.50
pay = hours * rate
print pay

x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print x1q3p9afd
\end{verbatim}
\afterverb
%
파이썬 인터프리터는 이들 3개 프로그램을 \emph{정확하게 동일하게} 바라보지만, 사람은 이들 프로그램을 매우 다르게 바라보고 이해하게 됩니다. 사람은 가장 빨리 두번째 프로그램의 의도를 알아차립니다. 왜냐하면 프로그래머가 변수에 저장되는 값에 관계없이 프로그래머의 {\bf 의도}를 나타내는 변수명을 사용했기 때문입니다.

현명하게 선택된 변수명을 \emph{기억하기 쉬운 변수명("mnemonic variable name")}이라고 합니다. 기억하기 좋은 영어 단어 "mnemonic"\footnote{ 
\url{http://en.wikipedia.org/wiki/Mnemonic 참조 바랍니다.}}
은 기억을 돕는다는 뜻입니다. 왜 변수를 생성했는지 기억하기 좋게 하기 위해서 기억하기 좋은 변수명을 선택합니다.

매우 훌륭하게 들리고, 기억하기 좋은 변수명을 만드는게 좋은 아이디어 같지만, 기억하기 좋은 변수명은 초보 프로그래머가 코드를 파싱하고 이해하는데 걸림돌이 되기도 한다. 왜냐하면 31개의 예약어도 기억하지 못하고 때때로 너무 서술적인 이름의 변수가 마치 우리가 일반적으로 사용하는 언어처럼 보여 잘 선택된 변수명처럼 보이지 않기 때문이다.

어떤 데이터를 반복하는 다음의 파이썬 코드를 살펴보자. 여러분은 곧 반복 루프를 보지만 이것이 무엇을 의미하는지 알기 위해서 퍼즐을 풀기시작할 것이다.

\beforeverb
\begin{verbatim}
for word in words:
    print word
\end{verbatim}
\afterverb
%
무엇이 일어나고 있는 것일까요? for, word, in 등등 어느 것이 예약어일까요? 변수명은 무엇일까요? 파이썬이 기본적으로 단어의 개념을 이해할까요? 초보 프로그래머는 어떤 부분의 코드가 이 예제와 동일해야 하는지와 단지 프로그래머의 선택에 의한 부분이 코드의 어느부분인지 분간하는데 애를 먹는다.

다음의 코드는 위의 코드와 동일하다.

\beforeverb
\begin{verbatim}
for slice in pizza:
    print slice
\end{verbatim}
\afterverb
%
초보 프로그래머가 이 코드를 보고 어떤 부분이 파이썬의 예약어이고 어느 부분이 프로그래머가 선택한 변수명인지 알 수 있다. 파이썬이 피자와 피자조각에 대한 근본적인 이해가 없고 피자는 하나 혹은 여러 조각으로 구성된다는 근본적인 사실을 알지 못한다.

하지만, 여러분의 프로그램이 데이터를 읽고 데이터의 단어를 찾는다면 {\tt 피자(pizza)}와 {\tt 피자조각(slice)}은 기억하기 좋은 변수명이 아니다. 이들 변수명은 프로그램의 의미를 왜곡시킬 수 있다.

좀 시간을 보낸 후에 흔한 예약어에 대해서 알게될 것이고 이들 예약어가 여러분에게 눈에 띄게 될 것이다.

{\tt {\bf for} word {\bf in} words{\bf :}\\
\verb"    "{\bf print} word }

{\tt for}, {\tt in}, {\tt print}, {\tt :}은 파이썬에서 정의된 예약어로 굵게 표시되어 있고, 프로그래머가 생성한 {\tt word}, {\tt words}는 굵게 표시되어 있지 않다. 많은 텍스트 에디터는 파이썬의 구문을 알고 있고 파이썬 예약어와 프로그래머의 변수를 구분하기 위해서 다른 색까로 구분지어준다. 잠시 후에 여러분은 이제 파이썬을 읽고 변수와 예약어에 대해서 빨리 구분할 수 있을 것이다.

\section{디버깅(Debugging)}
\index{debugging}

이 지점에서 여러분이 만들 것 같은 구문 오류는 \verb"odd~job", \verb"US$" 같은 특수문자를 포함한 잘못된 변수명과 {\tt class}, {\tt yield}같은 예약어를 변수명으로 사용하는 것이다. 

\index{syntax error}
\index{error!syntax}

변수명에 공백을 넣는다면, 파이썬은 연산자 없이 두 개의 피연산자로 생각합니다.

\beforeverb
\begin{verbatim}
>>> bad name = 5
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
구문 오류에 대해서, 구문오류 메세지는 그다지 도움이 되지 못합니다. 가장 흔한 오류 메세지는 {\tt SyntaxError: invalid syntax}, {\tt SyntaxError: invalid token}인데 둘다 그다지 도움이 되지 못합니다.

\index{error message}
\index{use before def}
\index{exception}
\index{runtime error}
\index{error!runtime}

여러분이 많이 만드는 실행 오류는 정의전에 사용(''use before def'')하는 것으로 변수에 값을 할당하기 전에 변수를 사용할 경우 발생합니다. 여러분이 변수명을 쓸 때도 발생할 수 있습니다.

\beforeverb
\begin{verbatim}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
\end{verbatim}
\afterverb
%
변수명은 대소문자를 구분합니다. {\tt LaTeX}는 {\tt latex}와 같지 않습니다.

\index{case-sensitivity, variable names}
\index{semantic error}
\index{error!semantic}

이 지점에서 여러분이 저지르기 쉬운 구문 오류는 연산자의 우선 순위일 것입니다. 예를 들어 $\frac{1}{2 \pi}$를 계산하기 위해서 다음과 같이 프로그램을 작성하게 되면 ...


\beforeverb
\begin{verbatim}
>>> 1.0 / 2.0 * pi
\end{verbatim}
\afterverb
%
나눗셈이 먼저 일어나서 $\pi / 2$를 같은 것이 아닙니다. 파이썬이 여러분이 쓴 의도를 알게할 수는 없습니다. 그래서 이런 경우 오류 메세지를 얻지는 않지만 잘못된 답을 여러분은 얻게 될 것입니다.

\index{order of operations}


\section{용어 설명}

\begin{description}

\item[할당(assignment):] 변수에 값을 할당하는 스테이트먼트
\index{assignment}

\item[결합(concatenate):] 두 개의 피연산자 끝과 끝을 합치는 것
\index{concatenation}

\item[주석(comment):] 다른 프로그래머나 소스코드를 읽는 다른 사람을 위한 프로그램의 정보로 프로그램의 실행에는 아무런 영향이 없다.
\index{comment}

\item[평가(evaluate):] 하나의 값을 만들도록 연산을 실행함으로써 표현식을 간단히 하는 것

\item[(표현)식(expression):] 하나의 결과값을 만드는 변수, 연산자, 값의 조합
\index{expression}

\item[부동 소수점(floating-point):] 분수를 가진 숫자를 표현하는 방식
\index{floating-point}

\item[플로어 나눗셈(floor division)] 두 숫자를 나누어 소수점이하 부분을 절사하는 연산자
\index{floor division}

\item[정수(integer):] 완전수를 나타내는 형식
\index{integer}

\item[예약어(keyword):]  프로그램을 파싱하는 컴파일러가 사용하는 이미 예약된 단어; if, def, while 같은 예약어를 변수명으로 사용할 수 없다.
\index{keyword}

\item[니모닉(mnemonic):] 기억 보조, 변수에 저장된 것을 기억하기 좋게 변수에 니모닉 이름을 부여한다.
\index{mnemonic}

\item[나머지 연산자(modulus operator):] 
퍼센트 기호 ({\tt \%}) 로 표시되고 정수를 가지고 한 숫자를 다른 숫자로 나누었을 때 나머지
\index{modulus operator}
\index{operator!modulus}

\item[피연산자(operand):]  연산자가 연산을 수행하는 값의 하나
\index{operand}

\item[연산자(operator):] 덧셈, 곱셈, 문자열 결합 같은 간단한 연산을 나타내는 특별 기호
\index{operator}

\item[순위 규칙(rules of precedence):] 여러 개의 연산자와 피연산자를 포함한 표현식이 평가되는 실행 순서를 정한 규칙 집합
\index{rules of precedence}
\index{precedence}

\item[스테이트먼트(statement):]  명령이나 액션을 나타내는 코드 부문. 지금까지 assignment, print 스테이트먼트를 보았습니다.
\index{statement}

\item[문자열(string):] 일련의 문자를 나타내는 형식
\index{string}

\item[형(type):] 값의 범주. 지금까지 여러분이 살펴본 형은 정수 (type {\tt int}), 부동 소수점수 (type {\tt float}), 문자열 (type {\tt str}) 입니다.
\index{type}

\item[값(value):]  프로그램이 다루는 숫자나 문자 같은 데이터의 기본 단위중 하나
\index{value}

\item[변수(variable):] 값을 참조하는 이름
\index{variable}

\end{description}

\section{연습문제}

\begin{ex}
\verb"raw_input"을 사용하여 사용자의 이름을 입력받고 환영하는 프로그램을 작성하세요.

\begin{verbatim}
Enter your name: Chuck
Hello Chuck
\end{verbatim}

\end{ex}

\begin{ex}
급여를 지불하기 위해서 사용자로부터 근로시간과 시간당 임금을 계산하는 프로그램을 작성하세요.
\begin{verbatim}
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25
\end{verbatim}
\end{ex}
%
지금은 급여가 정확하게 소수점 두자리까지 표현되지 않아도 된다. 만약 원하다면, 파이썬의 빌트인 {\tt round} 함수를 사용하여 소수점 아래 두자리까지 반올림하여 작성할 수 있다.

\begin{ex}
다음 할당 스테이트먼트를 실행한다고 합시다.

\begin{verbatim}
width = 17
height = 12.0
\end{verbatim}

다음 표현식에 대해서 표현식의 값과 표현식의 값의 형을 작성하세요.

\begin{enumerate}

\item {\tt width/2}

\item {\tt width/2.0}

\item {\tt height/3}

\item {\tt 1 + 2 * 5}

\end{enumerate}

정답을 확인하기 위해서 파이썬 인터프리터를 사용하세요.

\end{ex}

\begin{ex}
사용자에게서 섭시 온도를 입력받아 화씨온도롤 변환하고 변환된 온도를 출력하는 프로그램을 작성하세요.
\end{ex}


